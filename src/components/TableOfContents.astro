---
interface Heading {
  id: string;
  text: string;
  level: number;
}

interface Props {
  headings: Heading[];
}

const { headings } = Astro.props;
---

{headings.length > 0 && (
  <>
    {/* Mobile TOC Button */}
    <button
      id="toc-mobile-toggle"
      class="fixed bottom-6 right-6 z-40 md:hidden w-12 h-12 rounded-full bg-[var(--color-md-primary)] text-[var(--color-md-on-primary)] shadow-lg flex items-center justify-center hover:bg-[var(--color-md-primary-container)] hover:text-[var(--color-md-on-primary-container)] transition-colors"
      aria-label="显示目录"
    >
      <span class="material-symbols-outlined">list</span>
    </button>

    {/* Mobile TOC Overlay */}
    <div
      id="toc-mobile-overlay"
      class="fixed inset-0 z-50 bg-black/50 md:hidden hidden"
    >
      <div class="absolute right-0 top-0 bottom-0 w-72 max-w-[85vw] bg-[var(--color-md-surface)] shadow-xl overflow-y-auto">
        <div class="sticky top-0 bg-[var(--color-md-surface)] z-10 p-4 border-b border-[var(--color-md-outline-variant)] flex items-center justify-between">
          <h3 class="title-medium text-[var(--color-md-on-surface)] flex items-center gap-2">
            <span class="material-symbols-outlined text-sm">list</span>
            目录
          </h3>
          <button
            id="toc-mobile-close"
            class="p-2 rounded-full hover:bg-[var(--color-md-surface-variant)] transition-colors"
            aria-label="关闭目录"
          >
            <span class="material-symbols-outlined">close</span>
          </button>
        </div>
        <nav class="p-4">
          <ul class="space-y-1">
            {headings.map((heading) => (
              <li>
                <button
                  class="toc-link w-full text-left py-2 px-3 rounded-lg transition-colors text-sm hover:bg-[var(--color-md-surface-variant)]"
                  data-target={heading.id}
                  style={`padding-left: ${(heading.level - 1) * 12 + 12}px`}
                >
                  {heading.text}
                </button>
              </li>
            ))}
          </ul>
        </nav>
      </div>
    </div>

    {/* Desktop TOC Sidebar - Show only when there's enough space on the right */}
    <aside class="hidden fixed right-6 top-32 w-56 z-30">
      <div class="bg-[var(--color-md-surface)] rounded-xl border border-[var(--color-md-outline-variant)] shadow-sm overflow-hidden max-h-[calc(100vh-160px)] flex flex-col">
        <div class="p-3 border-b border-[var(--color-md-outline-variant)] flex-shrink-0">
          <h3 class="title-small text-[var(--color-md-on-surface)] flex items-center gap-2">
            <span class="material-symbols-outlined text-sm">list</span>
            目录
          </h3>
        </div>
        <nav class="overflow-y-auto flex-1 p-2">
          <ul class="space-y-0.5">
            {headings.map((heading) => (
              <li>
                <button
                  class="toc-link w-full text-left py-1.5 px-3 rounded-lg transition-all duration-200 text-xs hover:bg-[var(--color-md-surface-variant)]"
                  data-target={heading.id}
                  style={`padding-left: ${(heading.level - 1) * 12 + 12}px`}
                >
                  {heading.text}
                </button>
              </li>
            ))}
          </ul>
        </nav>
      </div>
    </aside>

    {/* TOC FAB - Show when desktop TOC is hidden */}
    {headings.length > 0 && (
      <button
        id="toc-fab"
        class="fixed z-40 w-14 h-14 rounded-full bg-[var(--color-md-primary)] text-[var(--color-md-on-primary)] shadow-lg flex items-center justify-center hover:bg-[var(--color-md-primary-container)] hover:text-[var(--color-md-on-primary-container)] transition-colors toc-element"
        aria-label="显示目录"
      >
        <span class="material-symbols-outlined">list</span>
      </button>
    )}

    <script>
      // Dynamic TOC visibility based on available space
      (function() {
        const toc = document.querySelector('aside.fixed.right-6');
        const tocFab = document.getElementById('toc-fab');
        const tocMobileOverlay = document.getElementById('toc-mobile-overlay');
        const tocMobileClose = document.getElementById('toc-mobile-close');
        const tocLinks = document.querySelectorAll('.toc-link');
        const tocElements = document.querySelectorAll('.toc-element');

        function updateTocVisibility() {
          // Find the article content container
          const article = document.querySelector('article .max-w-3xl');
          if (!article || !toc || !tocFab) return;
          
          const articleRect = article.getBoundingClientRect();
          const tocWidth = 224; // w-56 = 224px
          const rightMargin = 24; // right-6 = 24px
          
          // Calculate available space to the right of the article
          const availableWidth = window.innerWidth - articleRect.right - rightMargin;
          
          // Minimum space needed for TOC (with some buffer)
          const minSpaceNeeded = tocWidth + 16;
          
          // Check if article is not full width (has space on right)
          const hasSpaceOnRight = articleRect.right < window.innerWidth - 100;
          
          // Show TOC sidebar only if there's enough space on the right
          if (hasSpaceOnRight && availableWidth >= minSpaceNeeded) {
            toc.style.display = 'block';
            tocFab.style.display = 'none';
          } else {
            toc.style.display = 'none';
            tocFab.style.display = 'flex';
          }
        }

        function adjustFabPosition() {
          // Adjust FAB position to avoid overlapping with BackToTop
          if (!tocFab) return;
          
          const backToTop = document.querySelector('[class*="fixed"][class*="bottom-6"][class*="right-6"]:not(.toc-element)');
          if (!backToTop) return;
          
          const tocFabRect = tocFab.getBoundingClientRect();
          const backToTopRect = backToTop.getBoundingClientRect();
          
          // Check if they would overlap
          const overlap = !(tocFabRect.right < backToTopRect.left || 
                          tocFabRect.left > backToTopRect.right || 
                          tocFabRect.bottom < backToTopRect.top || 
                          tocFabRect.top > backToTopRect.bottom);
          
          if (overlap) {
            // Move FAB to the left of BackToTop
            tocFab.style.right = `${backToTopRect.right + 24}px`;
          } else {
            // Reset to default position
            tocFab.style.right = '24px';
          }
        }

        // Initial check
        updateTocVisibility();
        adjustFabPosition();

        // Recheck on resize
        window.addEventListener('resize', () => {
          updateTocVisibility();
          adjustFabPosition();
        });

        // Recheck on scroll (for dynamic content/layout)
        window.addEventListener('scroll', () => {
          requestAnimationFrame(() => {
            updateTocVisibility();
          });
        }, { passive: true });

        // FAB click handler
        if (tocFab && tocMobileOverlay) {
          tocFab.addEventListener('click', () => {
            tocMobileOverlay.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
          });
        }

        // Mobile close handler
        if (tocMobileClose && tocMobileOverlay) {
          tocMobileClose.addEventListener('click', () => {
            tocMobileOverlay.classList.add('hidden');
            document.body.style.overflow = '';
          });
        }

        // Close overlay when clicking backdrop
        if (tocMobileOverlay) {
          tocMobileOverlay.addEventListener('click', (e) => {
            if (e.target === tocMobileOverlay) {
              tocMobileOverlay.classList.add('hidden');
              document.body.style.overflow = '';
            }
          });
        }

        // Smooth scroll to section
        tocLinks.forEach(link => {
          link.addEventListener('click', (e) => {
            e.preventDefault();
            const targetId = link.getAttribute('data-target');
            const target = targetId ? document.getElementById(targetId) : null;
            if (target) {
              const offset = 80;
              const elementPosition = target.getBoundingClientRect().top;
              const offsetPosition = elementPosition + window.scrollY - offset;
              window.scrollTo({
                top: offsetPosition,
                behavior: 'smooth'
              });
              // Close mobile overlay if open
              if (tocMobileOverlay) {
                tocMobileOverlay.classList.add('hidden');
                document.body.style.overflow = '';
              }
            }
          });
        });

        // Scroll spy - highlight active heading
        const observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const id = entry.target.id;
              tocLinks.forEach(link => {
                if (link.getAttribute('data-target') === id) {
                  link.classList.add('bg-[var(--color-md-primary-container)]', 'text-[var(--color-md-on-primary-container)]', 'font-medium');
                  link.classList.remove('text-[var(--color-md-on-surface-variant)]');
                } else {
                  link.classList.remove('bg-[var(--color-md-primary-container)]', 'text-[var(--color-md-on-primary-container)]', 'font-medium');
                  link.classList.add('text-[var(--color-md-on-surface-variant)]');
                }
              });
            }
          });
        }, {
          rootMargin: '-80px 0px -80% 0px',
          threshold: 0
        });

        // Observe all headings
        tocLinks.forEach(link => {
          const targetId = link.getAttribute('data-target');
          const target = targetId ? document.getElementById(targetId) : null;
          if (target) {
            observer.observe(target);
          }
        });

        // Adjust positions after layout is complete
        setTimeout(() => {
          updateTocVisibility();
          adjustFabPosition();
        }, 100);
        setTimeout(adjustFabPosition, 500);
      })();
    </script>

    <style>
      /* Show TOC only when there's enough horizontal space */
      @media (min-width: 1280px) {
        aside.fixed.right-6:not([style*="display: none;"]) {
          display: block !important;
        }
      }
    </style>
  </>
)}
